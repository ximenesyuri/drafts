#!/bin/bash

if [[ $- == *i* ]]; then

  __ML_MODE=0
  __ML_PREFIX="  > "
  __ML_PLEN=${#__ML_PREFIX}

__ml_set_normal_keys() {
    bind '"\C-m": accept-line'
    bind '"\e[A": previous-history'
    bind '"\e[B": next-history'
    bind '"\e": prefix-meta'

    # restore normal arrows + backspace/delete
    bind '"\e[D": backward-char'
    bind '"\eOD": backward-char'
    bind '"\e[C": forward-char'
    bind '"\eOC": forward-char'
    bind '"\C-h": backward-delete-char'
    bind '"\C-?": backward-delete-char'
    bind '"\C-d": delete-char'
    bind '"\e[3~": delete-char'
  } 

  # ---- helpers on current line ----

 __ml_current_line_bounds() {
  # computes __ml_line_start, __ml_line_end for position $1 or READLINE_POINT
  local buf=$READLINE_LINE
  local pos=${1:-$READLINE_POINT}
  local len=${#buf}
  local i last_nl=-1
  for ((i=0; i<pos; i++)); do
    [[ ${buf:i:1} == $'\n' ]] && last_nl=$i
  done
  __ml_line_start=$(( last_nl + 1 ))
  local nl=-1
  for ((i=__ml_line_start; i<len; i++)); do
    if [[ ${buf:i:1} == $'\n' ]]; then
      nl=$i
      break
    fi
  done
  __ml_line_end=$(( nl == -1 ? len : nl ))
}
__ml_line_is_prefixed() {
  # returns 0 if this line (start at $1) has the "  > " prefix and is NOT the first line
  local start=$1
  if (( start == 0 )); then
    return 1
  fi
  [[ ${READLINE_LINE:start:__ML_PLEN} == "$__ML_PREFIX" ]]
} 
  # ---- core editing primitives ----

  __ml_newline() {
    [[ $__ML_MODE -eq 1 ]] || return
    local insert=$'\n'"$__ML_PREFIX"
    local before=${READLINE_LINE:0:READLINE_POINT}
    local after=${READLINE_LINE:READLINE_POINT}
    READLINE_LINE="${before}${insert}${after}"
    (( READLINE_POINT += ${#insert} ))
  }

    __ml_up() {
    [[ $__ML_MODE -eq 1 ]] || return

    local buf=$READLINE_LINE
    local pos=$READLINE_POINT
    local len=${#buf}

    # Get current line bounds and column
    __ml_current_line_bounds "$pos"
    local cur_start=$__ml_line_start
    local cur_end=$__ml_line_end
    local col=$(( pos - cur_start ))

    # If already on the first line, nothing to do
    (( cur_start == 0 )) && return

    # Previous line end is the newline just before cur_start
    local prev_end=$(( cur_start - 1 ))  # index of '\n' ending previous line

    # Find previous line start (newline before prev_end, or 0)
    local i prev_nl=-1
    for ((i=0; i<prev_end; i++)); do
      [[ ${buf:i:1} == $'\n' ]] && prev_nl=$i
    done
    local prev_start=$(( prev_nl + 1 ))

    # Length of previous line (number of characters, excluding its '\n')
    local prev_len=$(( prev_end - prev_start ))

    # Desired column on previous line
    local target_col=$col

    # Enforce prefix on prefixed lines
    if __ml_line_is_prefixed "$prev_start"; then
      local min_col=$__ML_PLEN
      (( target_col < min_col )) && target_col=$min_col
    fi

    # Clamp to end of previous line
    (( target_col > prev_len )) && target_col=$prev_len

    READLINE_POINT=$(( prev_start + target_col ))
  }

  __ml_down() {
    [[ $__ML_MODE -eq 1 ]] || return

    local buf=$READLINE_LINE
    local pos=$READLINE_POINT
    local len=${#buf}

    # Get current line bounds and column
    __ml_current_line_bounds "$pos"
    local cur_start=$__ml_line_start
    local cur_end=$__ml_line_end
    local col=$(( pos - cur_start ))

    # If already on the last line, nothing to do
    (( cur_end >= len )) && return

    # Next line starts right after current line's '\n'
    local next_start=$(( cur_end + 1 ))

    # Find next line end (next '\n' or end of buffer)
    local i next_nl=-1
    for ((i=next_start; i<len; i++)); do
      if [[ ${buf:i:1} == $'\n' ]]; then
        next_nl=$i
        break
      fi
    done
    local next_end=$(( next_nl == -1 ? len : next_nl ))

    # Length of next line (excluding its '\n')
    local next_len=$(( next_end - next_start ))

    # Desired column on next line
    local target_col=$col

    # Enforce prefix on prefixed lines
    if __ml_line_is_prefixed "$next_start"; then
      local min_col=$__ML_PLEN
      (( target_col < min_col )) && target_col=$min_col
    fi

    # Clamp to end of next line
    (( target_col > next_len )) && target_col=$next_len

    READLINE_POINT=$(( next_start + target_col ))
  } 

  __ml_backspace() {
    [[ $__ML_MODE -eq 1 ]] || return
    local buf=$READLINE_LINE pos=$READLINE_POINT
    (( pos == 0 )) && return

    __ml_current_line_bounds "$pos"
    local line_start=$__ml_line_start
    local col=$(( pos - line_start ))

    if __ml_line_is_prefixed "$line_start"; then
      (( col <= __ML_PLEN )) && return
    fi

    local before=${buf:0:pos-1}
    local after=${buf:pos}
    READLINE_LINE="${before}${after}"
    READLINE_POINT=$((pos-1))
  }

  __ml_delete() {
    [[ $__ML_MODE -eq 1 ]] || return
    local buf=$READLINE_LINE pos=$READLINE_POINT len=${#buf}
    (( pos >= len )) && return

    __ml_current_line_bounds "$pos"
    local line_start=$__ml_line_start
    local col=$(( pos - line_start ))

    if __ml_line_is_prefixed "$line_start"; then
      (( col < __ML_PLEN )) && return
    fi

    local before=${buf:0:pos}
    local after=${buf:pos+1}
    READLINE_LINE="${before}${after}"
  }

  __ml_left() {
    [[ $__ML_MODE -eq 1 ]] || return
    local buf=$READLINE_LINE pos=$READLINE_POINT
    (( pos == 0 )) && return

    local new_pos=$((pos-1))
    __ml_current_line_bounds "$new_pos"
    local line_start=$__ml_line_start
    local col=$(( new_pos - line_start ))

    if __ml_line_is_prefixed "$line_start"; then
      local min_pos=$(( line_start + __ML_PLEN ))
      (( new_pos < min_pos )) && new_pos=$min_pos
    fi

    READLINE_POINT=$new_pos
  }

__ml_set_multiline_keys() {
  bind -x '"\C-m": __ml_newline'   # Enter: newline with "  > "

  # Up/Down: bind both CSI and SS3 variants
  bind -x '"\e[A": __ml_up'        # ^[[A
  bind -x '"\e[B": __ml_down'      # ^[[B
  bind -x '"\eOA": __ml_up'        # ^[OA (some terms/tmux)
  bind -x '"\eOB": __ml_down'      # ^[OB

  bind -x '"\C-h": __ml_backspace'
  bind -x '"\C-?": __ml_backspace'
  bind -x '"\C-d": __ml_delete'
  bind -x '"\e[3~": __ml_delete'

  bind -x '"\e[D": __ml_left'
  bind -x '"\eOD": __ml_left'

  # IMPORTANT: do *not* bind bare ESC here; leave it as prefix-meta
  # If you want an exit key, use something like:
  # bind -x '"\C-g": __ml_escape'
}
  # ---- join & execute / escape ----

  __ml_strip_prefixes_and_join() {
    local code=$1
    code=${code#"${__ML_PREFIX}"}             # first line if prefixed
    code=${code//$'\n'"${__ML_PREFIX}"/ }     # other lines
    code=${code//$'\n'/ }                     # any stray newlines
    printf '%s' "$code"
  }

  __ml_escape() {
    if [[ $__ML_MODE -eq 1 ]]; then
      local code
      code=$(__ml_strip_prefixes_and_join "$READLINE_LINE")
      READLINE_LINE=$code
      READLINE_POINT=${#READLINE_LINE}
      __ML_MODE=0
      __ml_set_normal_keys
    fi
  }

    __ml_exec_and_exit() {
    # Turn multiline + "  > " prefixes into a single command line
    local code
    code=$(__ml_strip_prefixes_and_join "$READLINE_LINE")

    # Expand PS1 as a real prompt string
    local prompt="${PS1@P}"

    if [[ -n $code ]]; then
      # Print a newline, then the prompt + the command (like normal mode),
      # then run the command.
      printf '\n%s%s\n' "$prompt" "$code"
      builtin eval "$code"
    else
      # If nothing to run, just move to a new line
      printf '\n'
    fi

    READLINE_LINE=''
    READLINE_POINT=0
    __ML_MODE=0
    __ml_set_normal_keys
  }


  # ---- mode toggles ----

  __ml_ctrl_bracket() {
    if [[ $__ML_MODE -eq 0 ]]; then
      __ML_MODE=1
      __ml_set_multiline_keys
      READLINE_POINT=${#READLINE_LINE}
      __ml_newline                 # first "  > " line
    else
      __ml_exec_and_exit
    fi
  }

__ml_prompt_hook() {
    if [[ $__ML_MODE -eq 1 ]]; then
      __ML_MODE=0
      __ml_set_normal_keys
    fi
    # Run any original PROMPT_COMMAND the user had
    if [[ -n "$__ML_OLD_PROMPT_COMMAND" ]]; then
      eval "$__ML_OLD_PROMPT_COMMAND"
    fi
  }

  # Install our prompt hook, preserving any existing PROMPT_COMMAND
  if [[ -n "$PROMPT_COMMAND" && "$PROMPT_COMMAND" != *"__ml_prompt_hook"* ]]; then
    __ML_OLD_PROMPT_COMMAND=$PROMPT_COMMAND
    PROMPT_COMMAND="__ml_prompt_hook"
  elif [[ -z "$PROMPT_COMMAND" ]]; then
    PROMPT_COMMAND="__ml_prompt_hook"
  fi
 
  __ml_set_normal_keys
  bind -x '"\C-]": __ml_ctrl_bracket'

fi

