#! /bin/bash

function g() {

    if ! command -v "awk" > /dev/null 2>&1; then
        echo "error: missing awk."
        return 1
    fi
    if ! command -v "fzf" > /dev/null 2>&1; then
        echo "error: missing fzf."
        return 1
    fi

    case "$1" in

    undo)
        shift

        if [ $# -eq 0 ]; then
            echo "Usage: g undo <number>  OR  g undo <path> [<path>...]" >&2
            return 1
        fi

        if [ $# -eq 1 ] && [[ "$1" =~ ^[0-9]+$ ]]; then
            steps="$1"
            target_ref="HEAD~$steps"

            if ! command git rev-parse --verify "$target_ref" >/dev/null 2>&1; then
                echo "Target commit '$target_ref' does not exist." >&2
                return 1
            fi

            echo "This will run: git reset --hard $target_ref"
            read -r -p "Are you sure you want to discard all uncommitted changes and move HEAD back $steps commit(s)? [y/N] " answer
            case "$answer" in
                [Yy]*)
                    command git reset --hard "$target_ref"
                    ;;
                *)
                    echo "Aborted."
                    return 1
                    ;;
            esac
        else
            command git restore -- "$@"
        fi
        ;; 
    info) command git log -1 --oneline; command git status ;;
    remote)
        shift
        sub="$1"

        case "$sub" in
            new)
                shift
                local name=""
                local url=""

                while [ "$#" -gt 0 ]; do
                    case "$1" in
                        --name)
                            shift
                            name="$1"
                            ;;
                        --url)
                            shift
                            url="$1"
                            ;;
                        *)
                            if [ -z "$name" ]; then
                                name="$1"
                            elif [ -z "$url" ]; then
                                url="$1"
                            else
                                echo "Unexpected argument for 'g remote new': $1" >&2
                                return 1
                            fi
                            ;;
                    esac
                    shift
                done

                if [ -z "$name" ]; then
                    echo "Remote name is required. Usage: g remote new <name> <url> or g remote new --name <name> --url <url>" >&2
                    return 1
                fi
                if [ -z "$url" ]; then
                    echo "Remote URL is required. Usage: g remote new <name> <url> or g remote new --name <name> --url <url>" >&2
                    return 1
                fi

                command git remote add "$name" "$url"
                ;;
            list|ls)
                command git remote -v | awk '{
                    key = $1 " " $2;
                    if (!seen[key]++) {
                        printf "%-20s %s\n", $1, $2;
                    }
                }'
                ;;
            rm)
                shift
                local targets=()

                if [ "$#" -eq 0 ]; then
                    local remotes
                    remotes=$(command git remote -v 2>/dev/null | awk '{print $1 "\t" $2}' | sort -u)
                    [ -z "$remotes" ] && { echo "No remotes configured."; return 1; }

                    local selected
                    selected=$(printf '%s\n' "$remotes" | \
                        fzf --multi --prompt="Remotes to delete: " \
                            --height=40% --layout=reverse --border)
                    [ -z "$selected" ] && { echo "No remotes selected."; return 1; }

                    while IFS= read -r line; do
                        [ -z "$line" ] && continue
                        local name="${line%%$'\t'*}"
                        targets+=("$name")
                    done <<< "$selected"
                else
                    for arg in "$@"; do
                        if command git remote get-url "$arg" >/dev/null 2>&1; then
                            targets+=("$arg")
                        else
                            local by_url
                            by_url=$(command git remote -v | awk -v u="$arg" '$2==u {print $1}' | sort -u)
                            if [ -z "$by_url" ]; then
                                echo "No remote found matching '$arg'." >&2
                            else
                                while IFS= read -r name; do
                                    [ -n "$name" ] && targets+=("$name")
                                done <<< "$by_url"
                            fi
                        fi
                    done
                fi

                if [ "${#targets[@]}" -eq 0 ]; then
                    echo "No remotes to delete." >&2
                    return 1
                fi

                local uniq_targets=()
                local t u skip
                for t in "${targets[@]}"; do
                    skip=0
                    for u in "${uniq_targets[@]}"; do
                        if [ "$u" = "$t" ]; then
                            skip=1
                            break
                        fi
                    done
                    [ "$skip" -eq 0 ] && uniq_targets+=("$t")
                done

                echo "Remotes to delete: ${uniq_targets[*]}"
                read -r -p "Are you sure you want to delete these remotes? [y/N] " ans
                case "$ans" in
                    [Yy]*)
                        ;;
                    *)
                        echo "Aborted."
                        return 1
                        ;;
                esac

                for r in "${uniq_targets[@]}"; do
                    command git remote remove "$r"
                done
                ;;
            update)
                shift
                local remote_name="$1"
                [ -z "$remote_name" ] && {
                    echo "Usage: g remote update <remote> --name <new_name> --url <new_url>" >&2
                    return 1
                }
                shift

                local new_name=""
                local new_url=""

                while [ "$#" -gt 0 ]; do
                    case "$1" in
                        --name)
                            shift
                            new_name="$1"
                            ;;
                        --url)
                            shift
                            new_url="$1"
                            ;;
                        *)
                            echo "Unknown option for 'g remote edit': $1" >&2
                            return 1
                            ;;
                    esac
                    shift
                done

                if [ -z "$new_name" ] && [ -z "$new_url" ]; then
                    echo "Provide at least one of --name or --url." >&2
                    return 1
                fi

                if ! command git remote get-url "$remote_name" >/dev/null 2>&1; then
                    echo "Remote '$remote_name' does not exist." >&2
                    return 1
                fi

                if [ -n "$new_name" ] && [ "$new_name" != "$remote_name" ]; then
                    command git remote rename "$remote_name" "$new_name" || return 1
                    remote_name="$new_name"
                fi

                if [ -n "$new_url" ]; then
                    command git remote set-url "$remote_name" "$new_url" || return 1
                fi
                ;;
            *)
                echo "Usage: g remote {new|list|ls|rm|edit} ..." >&2
                return 1
                ;;
        esac
        ;;
    conflict)
        shift
        local sub="${1:-}"
        case "$sub" in
            ""|"HEAD")
                local current_branch
                current_branch=$(command git symbolic-ref --quiet --short HEAD 2>/dev/null || echo "HEAD")
                local files
                files=$(command git diff --name-only --diff-filter=U)
                if [ -z "$files" ]; then
                    echo "No merge conflicts in current working tree (branch: $current_branch)."
                else
                    echo "Current working tree on '$current_branch' has conflicts in:"
                    printf '  %s\n' $files
                fi
                ;;
            ls)
                shift
                if [ -z "$1" ]; then
                    local files
                    files=$(command git diff --name-only --diff-filter=U)
                    if [ -z "$files" ]; then
                        echo "No files with conflicts."
                    else
                        printf '%s\n' $files
                    fi
                else
                    local file="$1"
                    if [ ! -f "$file" ]; then
                        echo "File '$file' not found." >&2
                        return 1
                    fi
                    if ! grep -q '^<<<<<<< ' "$file"; then
                        echo "No conflict markers found in '$file'."
                        return 0
                    fi
                    awk '
                        BEGIN { c = 0; showing = 0 }
                        /^<<<<<<< / {
                            c++
                            printf "===== Conflict %d (start line %d) =====\n", c, NR
                            showing = 1
                        }
                        showing { print }
                        /^>>>>>>> / {
                            printf "===== End of conflict %d (line %d) =====\n\n", c, NR
                            showing = 0
                        }
                    ' "$file"
                fi
                ;;
            resolve)
                shift

                local git_dir
                git_dir=$(command git rev-parse --git-dir 2>/dev/null) || {
                    echo "Not inside a git repository." >&2
                    return 1
                }

                local state_file="$git_dir/g-edit-state"
                if [ ! -f "$state_file" ]; then
                    local current_branch
                    current_branch=$(command git symbolic-ref --quiet --short HEAD 2>/dev/null || true)
                    if [ -z "$current_branch" ]; then
                        echo "You must be on a branch (not detached HEAD) to start 'g conflict resolve' session." >&2
                        return 1
                    fi

                    local old_commit_hash
                    old_commit_hash=$(command git rev-parse HEAD)

                    local has_rebase=0 has_merge=0
                    [ -d "$git_dir/rebase-apply" ] || [ -d "$git_dir/rebase-merge" ] && has_rebase=1
                    [ -f "$git_dir/MERGE_HEAD" ] && has_merge=1

                    if [ "$has_rebase" -eq 1 ]; then
                        echo "A rebase is in progress; moving it to a temp branch safely is not supported yet." >&2
                        echo "Finish/abort the rebase, or resolve conflicts in-place." >&2
                        return 1
                    fi

                    if [ "$has_merge" -eq 1 ]; then
                        local merge_head merge_msg
                        merge_head=$(cat "$git_dir/MERGE_HEAD" 2>/dev/null || echo "")
                        merge_msg=$(cat "$git_dir/MERGE_MSG" 2>/dev/null || echo "")

                        if [ -z "$merge_head" ]; then
                            echo "MERGE_HEAD not readable; cannot relocate merge to temp branch." >&2
                            return 1
                        fi

                        echo "A merge is in progress on '$current_branch'."
                        echo "To resolve it on a temporary branch, this will:"
                        echo "  - abort the current merge on '$current_branch'"
                        echo "  - create temp branch 'g-edit-${old_commit_hash:0:7}' from '$current_branch' (at $old_commit_hash)"
                        echo "  - re-run the same merge there"
                        echo "Any uncommitted changes and current conflict contents on '$current_branch'"
                        echo "will be discarded and recreated on the temp branch."
                        read -r -p "Proceed? [y/N] " ans
                        case "$ans" in
                            [Yy]*)
                                ;;
                            *)
                                echo "Aborted."
                                return 1
                                ;;
                        esac

                        {
                            printf '%s\n' "$current_branch"
                            printf '%s\n' "$old_commit_hash"
                        } > "$state_file"

                        local short_hash=${old_commit_hash:0:7}
                        local work_branch="g-edit-${short_hash}"

                        echo "Aborting merge on '$current_branch'..."
                        if ! command git merge --abort; then
                            echo "Failed to abort merge on '$current_branch'." >&2
                            rm -f "$state_file"
                            return 1
                        fi

                        echo "Creating temporary merge-resolve branch '$work_branch' from '$current_branch'..."
                        if ! command git branch "$work_branch" "$old_commit_hash"; then
                            echo "Failed to create temporary branch '$work_branch'." >&2
                            rm -f "$state_file"
                            return 1
                        fi
                        if ! command git checkout "$work_branch"; then
                            echo "Failed to checkout temporary branch '$work_branch'." >&2
                            rm -f "$state_file"
                            return 1
                        fi

                        echo "Re-running merge into '$work_branch'..."
                        if [ -n "$merge_msg" ]; then
                            command git merge -m "$merge_msg" "$merge_head" || true
                        else
                            command git merge "$merge_head" || true
                        fi

                        echo "Now on temporary branch '$work_branch' with the merge in progress."
                        echo "Resolve conflicts here (e.g. with 'g conflict resolve <file>'),"
                        echo "commit the result when done, then run 'g apply -d' to move it back to '$current_branch'."

                    else
                        {
                            printf '%s\n' "$current_branch"
                            printf '%s\n' "$old_commit_hash"
                        } > "$state_file"

                        local short_hash=${old_commit_hash:0:7}
                        local work_branch="g-edit-${short_hash}"

                        echo "Creating temporary conflict-resolve branch '$work_branch' from '$current_branch'..."
                        if ! command git branch "$work_branch" "$current_branch"; then
                            echo "Failed to create temporary branch '$work_branch'." >&2
                            rm -f "$state_file"
                            return 1
                        fi
                        if ! command git checkout "$work_branch"; then
                            echo "Failed to checkout temporary branch '$work_branch'." >&2
                            rm -f "$state_file"
                            return 1
                        fi

                        echo "Now on temporary branch '$work_branch'."
                        echo "Resolve conflicts here (e.g. with 'g conflict resolve <file>'),"
                        echo "commit your changes, then run 'g apply -d' to apply them back."
                    fi
                else
                    local original_branch old_commit_hash
                    {
                        read -r original_branch
                        read -r old_commit_hash
                    } < "$state_file"
                    local expected_branch="g-edit-${old_commit_hash:0:7}"
                    local current_branch
                    current_branch=$(command git symbolic-ref --quiet --short HEAD 2>/dev/null || true)
                    if [ "$current_branch" != "$expected_branch" ]; then
                        echo "Conflict/edit session expects branch '$expected_branch', but you are on '$current_branch'." >&2
                        echo "Switch to '$expected_branch' or delete '$state_file' to start a new session." >&2
                        return 1
                    fi
                fi

                if [ -z "$1" ]; then
                    local files
                    files=$(command git diff --name-only --diff-filter=U)
                    if [ -z "$files" ]; then
                        echo "No files with conflicts to resolve."
                        return 0
                    fi
                    if ! command -v fzf >/dev/null 2>&1; then
                        echo "fzf is required for interactive selection (g conflict resolve)." >&2
                        printf '%s\n' $files
                        return 1
                    fi
                    local selected
                    selected=$(printf '%s\n' $files | \
                        fzf --multi --prompt="Select files to resolve: " \
                            --height=40% --layout=reverse --border)
                    [ -z "$selected" ] && { echo "No files selected."; return 1; }

                    local f
                    for f in $selected; do
                        g conflict resolve "$f" || return 1
                    done
                else
                    local file="$1"
                    if [ ! -f "$file" ]; then
                        echo "File '$file' not found." >&2
                        return 1
                    fi
                    if ! grep -q '^<<<<<<< ' "$file"; then
                        echo "No conflict markers found in '$file'."
                        return 0
                    fi

                    local tmp_out tmp_ours tmp_theirs
                    tmp_out=$(mktemp)
                    tmp_ours=$(mktemp)
                    tmp_theirs=$(mktemp)

                    local in_conflict=0 side=""
                    local -a block_lines ours_lines theirs_lines

                    while IFS= read -r line || [ -n "$line" ]; do
                        if [ "$in_conflict" -eq 0 ]; then
                            case "$line" in
                                "<<<<<<< "*)
                                    in_conflict=1
                                    side="ours"
                                    block_lines=("$line")
                                    ours_lines=()
                                    theirs_lines=()
                                    ;;
                                *)
                                    printf '%s\n' "$line" >> "$tmp_out"
                                    ;;
                            esac
                        else
                            case "$side" in
                                ours)
                                    if [ "$line" = "=======" ]; then
                                        block_lines+=("$line")
                                        side="theirs"
                                    else
                                        block_lines+=("$line")
                                        ours_lines+=("$line")
                                    fi
                                    ;;
                                theirs)
                                    block_lines+=("$line")
                                    case "$line" in
                                        ">>>>>>> "*)
                                            printf '%s\n' "${ours_lines[@]}" > "$tmp_ours"
                                            printf '%s\n' "${theirs_lines[@]}" > "$tmp_theirs"

                                            local plus_file minus_file
                                            plus_file=$(mktemp "/tmp/plus-XXXX")
                                            minus_file=$(mktemp "/tmp/minus-XXXX")
                                            cp "$tmp_ours" "$plus_file"
                                            cp "$tmp_theirs" "$minus_file"

                                            echo
                                            echo "========================================"
                                            echo "Conflict in $file"
                                            echo "----------------------------------------"
                                            command git --no-pager diff --no-index --color \
                                                "$plus_file" "$minus_file" || true
                                            echo "----------------------------------------"
                                            echo "plus  = current branch (ours)  -> $plus_file"
                                            echo "minus = other branch (theirs) -> $minus_file"
                                            while true; do
                                                if ! read -r -p "Choose [+] plus, [-] minus, [+-] or [-+], [Enter=skip], [q/quit]: " ans </dev/tty; then
                                                    echo "Input closed; aborting conflict resolution for '$file'." >&2
                                                    rm -f "$tmp_out" "$tmp_ours" "$tmp_theirs" "$plus_file" "$minus_file"
                                                    return 1
                                                fi
                                                case "$ans" in
                                                    "+")
                                                        printf '%s\n' "${ours_lines[@]}" >> "$tmp_out"
                                                        rm -f "$plus_file" "$minus_file"
                                                        break
                                                        ;;
                                                    "-")
                                                        printf '%s\n' "${theirs_lines[@]}" >> "$tmp_out"
                                                        rm -f "$plus_file" "$minus_file"
                                                        break
                                                        ;;
                                                    "+-")
                                                        printf '%s\n' "${ours_lines[@]}" >> "$tmp_out"
                                                        printf '%s\n' "${theirs_lines[@]}" >> "$tmp_out"
                                                        rm -f "$plus_file" "$minus_file"
                                                        break
                                                        ;;
                                                    "-+")
                                                        printf '%s\n' "${theirs_lines[@]}" >> "$tmp_out"
                                                        printf '%s\n' "${ours_lines[@]}" >> "$tmp_out"
                                                        rm -f "$plus_file" "$minus_file"
                                                        break
                                                        ;;
                                                    "")
                                                        printf '%s\n' "${block_lines[@]}" >> "$tmp_out"
                                                        rm -f "$plus_file" "$minus_file"
                                                        break
                                                        ;;
                                                    q|Q|quit|QUIT)
                                                        rm -f "$tmp_out" "$tmp_ours" "$tmp_theirs" "$plus_file" "$minus_file"
                                                        echo "Aborted conflict resolution for '$file'."
                                                        return 1
                                                        ;;
                                                    *)
                                                        echo "Please answer with +, -, +-, -+, Enter, or q/quit."
                                                        ;;
                                                esac
                                            done

                                            in_conflict=0
                                            side=""
                                            block_lines=()
                                            ours_lines=()
                                            theirs_lines=()
                                            ;;
                                        *)
                                            theirs_lines+=("$line")
                                            ;;
                                    esac
                                    ;;
                            esac
                        fi
                    done < "$file"

                    rm -f "$tmp_ours" "$tmp_theirs"

                    if [ "$in_conflict" -ne 0 ]; then
                        rm -f "$tmp_out"
                        echo "Parsing error: unterminated conflict markers in '$file'." >&2
                        return 1
                    fi

                    mv "$tmp_out" "$file"
                    echo "Updated '$file' with resolved conflicts on temporary branch."
                    echo "Remember to stage and commit when you are satisfied, then run 'g apply -d' to apply to the original branch."
                fi
                ;;
            diff)
                shift
                local file="$1"
                local tmp_ours tmp_theirs
                tmp_ours=$(mktemp) ; tmp_theirs=$(mktemp)
                if ! command git show ":2:$file" >"$tmp_ours" 2>/dev/null ||
                   ! command git show ":3:$file" >"$tmp_theirs" 2>/dev/null; then
                    rm -f "$tmp_ours" "$tmp_theirs"
                    echo "Could not extract ours/theirs for '$file'. Is it in conflict?" >&2
                    return 1
                fi
                vimdiff "$tmp_ours" "$tmp_theirs"
                local status=$?
                rm -f "$tmp_ours" "$tmp_theirs"
                return $status
                ;;
            *)
                local target_branch="$sub"
                if ! command git rev-parse --verify "$target_branch" >/dev/null 2>&1; then
                    echo "Branch or ref '$target_branch' not found." >&2
                    return 1
                fi
                local current_branch
                current_branch=$(command git symbolic-ref --quiet --short HEAD 2>/dev/null || echo "HEAD")
                local base
                if ! base=$(command git merge-base HEAD "$target_branch" 2>/dev/null); then
                    echo "No merge base between HEAD and '$target_branch'; cannot determine conflicts." >&2
                    return 1
                fi
                local out
                out=$(command git merge-tree "$base" HEAD "$target_branch") || true
                if printf '%s\n' "$out" | grep -q '^<<<<<<< '; then
                    echo "Merging '$target_branch' into '$current_branch' WOULD produce conflicts."
                else
                    echo "Merging '$target_branch' into '$current_branch' would NOT produce conflicts."
                fi
                ;;
        esac
        ;; 

    branch)
        shift; sub="$1"
        if [[ -z "$sub" ]]; then
            command git branch
            return
        fi
        case "$sub" in
            new)
                if [ -n "$2" ]; then
                    command git checkout -b "$2"
                else
                    echo "Error: Branch name required. Usage: git branch new <branch-name>"
                    return 1
                fi
                ;;
            list|ls)
                command git branch -a
                ;;
            rm)
                if [ -z "$2" ]; then
                    selected=$(command git branch --format="%(refname:short)" | \
                        fzf --multi --prompt="Branch to delete: " --height=30%)
                    [ -n "$selected" ] && \
                        for branch in $selected; do command git branch -D "$branch"; done
                else
                    command git branch -D "$2"
                fi
                ;;
            send)
                branch_to_push="${2:-HEAD}"
                command git push origin "${branch_to_push}"
                ;;
            rename)
                shift
                local target_branch=""
                local new_name=""

                if [ "$#" -gt 0 ] && [[ "$1" != --* ]]; then
                    target_branch="$1"
                    shift
                fi

                while [ "$#" -gt 0 ]; do
                    case "$1" in
                        --name)
                            shift
                            new_name="$1"
                            ;;
                        *)
                            echo "Unknown option for 'g branch rename': $1" >&2
                            return 1
                            ;;
                    esac
                    shift
                done

                if [ -z "$target_branch" ]; then
                    local selected
                    selected=$(command git branch --format="%(refname:short)" | \
                        fzf --prompt="Branch to rename: " --height=30% --layout=reverse --border)
                    [ -z "$selected" ] && { echo "No branch selected."; return 1; }
                    target_branch="$selected"
                else
                    if ! command git show-ref --verify --quiet "refs/heads/$target_branch"; then
                        echo "Branch '$target_branch' does not exist." >&2
                        return 1
                    fi
                fi

                if [ -z "$new_name" ]; then
                    read -r -p "New name for branch '$target_branch': " new_name
                    [ -z "$new_name" ] && { echo "No new branch name provided."; return 1; }
                fi

                command git branch -m "$target_branch" "$new_name"
                ;;
            rebase)
                shift
                local remote="origin"
                local branches=()

                while [ "$#" -gt 0 ]; do
                    case "$1" in
                        -r|--remote)
                            shift
                            remote="${1:-origin}"
                            ;;
                        *)
                            branches+=("$1")
                            ;;
                    esac
                    shift
                done

                if [ -z "$remote" ]; then
                    remote="origin"
                fi

                local current_branch
                current_branch=$(command git symbolic-ref --quiet --short HEAD 2>/dev/null || true)

                if [ "${#branches[@]}" -eq 0 ]; then
                    echo "Rebasing current HEAD from '$remote' (git pull $remote HEAD --rebase)..."
                    if ! command git pull "$remote" HEAD --rebase; then
                        echo "Rebase failed." >&2
                        return 1
                    fi
                    return 0
                fi

                local start_branch="$current_branch"

                for b in "${branches[@]}"; do
                    local target_branch="$b"
                    if [ "$b" = "./HEAD" ]; then
                        if [ -z "$current_branch" ]; then
                            echo "Cannot use ./HEAD when not on a branch." >&2
                            return 1
                        fi
                        target_branch="$current_branch"
                    fi

                    if ! command git show-ref --verify --quiet "refs/heads/$target_branch"; then
                        echo "Branch '$target_branch' does not exist; skipping." >&2
                        continue
                    fi

                    echo "Rebasing '$target_branch' from '$remote/$target_branch' (git pull $remote $target_branch --rebase)..."
                    if ! command git checkout "$target_branch"; then
                        echo "Failed to checkout '$target_branch'; skipping." >&2
                        continue
                    fi

                    if ! command git pull "$remote" "$target_branch" --rebase; then
                        echo "Rebase of '$target_branch' failed." >&2
                        if [ -n "$start_branch" ]; then
                            command git checkout "$start_branch" >/dev/null 2>&1 || true
                        fi
                        return 1
                    fi
                done

                if [ -n "$start_branch" ] && \
                   command git show-ref --verify --quiet "refs/heads/$start_branch"; then
                    command git checkout "$start_branch" >/dev/null 2>&1 || true
                fi
                ;;
            ff)
                shift
                local remote="origin"
                local branches=()

                while [ "$#" -gt 0 ]; do
                    case "$1" in
                        -r|--remote)
                            shift
                            remote="${1:-origin}"
                            ;;
                        *)
                            branches+=("$1")
                            ;;
                    esac
                    shift
                done

                if [ -z "$remote" ]; then
                    remote="origin"
                fi

                local current_branch
                current_branch=$(command git symbolic-ref --quiet --short HEAD 2>/dev/null || true)

                if [ "${#branches[@]}" -eq 0 ]; then
                    # g branch ff [ -r/--remote <remote> ]
                    echo "Fast-forwarding current HEAD from '$remote' (git pull $remote HEAD --ff)..."
                    if ! command git pull "$remote" HEAD --ff; then
                        echo "Fast-forward failed." >&2
                        return 1
                    fi
                    return 0
                fi

                local start_branch="$current_branch"

                for b in "${branches[@]}"; do
                    local target_branch="$b"
                    if [ "$b" = "./HEAD" ]; then
                        if [ -z "$current_branch" ]; then
                            echo "Cannot use ./HEAD when not on a branch." >&2
                            return 1
                        fi
                        target_branch="$current_branch"
                    fi

                    if ! command git show-ref --verify --quiet "refs/heads/$target_branch"; then
                        echo "Branch '$target_branch' does not exist; skipping." >&2
                        continue
                    fi

                    echo "Fast-forwarding '$target_branch' from '$remote/$target_branch' (git pull $remote $target_branch --ff)..."
                    if ! command git checkout "$target_branch"; then
                        echo "Failed to checkout '$target_branch'; skipping." >&2
                        continue
                    fi

                    if ! command git pull "$remote" "$target_branch" --ff; then
                        echo "Fast-forward of '$target_branch' failed." >&2
                        if [ -n "$start_branch" ]; then
                            command git checkout "$start_branch" >/dev/null 2>&1 || true
                        fi
                        return 1
                    fi
                done

                if [ -n "$start_branch" ] && \
                   command git show-ref --verify --quiet "refs/heads/$start_branch"; then
                    command git checkout "$start_branch" >/dev/null 2>&1 || true
                fi
                ;;
            merge)
                shift
                local branches=()
                local message=""

                while [ "$#" -gt 0 ]; do
                    case "$1" in
                        -m|--message)
                            shift
                            message="$*"
                            break
                            ;;
                        *)
                            branches+=("$1")
                            ;;
                    esac
                    shift
                done

                if [ "${#branches[@]}" -eq 0 ]; then
                    local selected
                    selected=$(command git branch --format="%(refname:short)" | \
                        fzf --multi --prompt="Branches to merge into current: " \
                            --height=40% --layout=reverse --border)
                    [ -z "$selected" ] && { echo "No branches selected."; return 1; }
                    read -r -a branches <<< "$selected"
                fi

                for b in "${branches[@]}"; do
                    if ! command git show-ref --verify --quiet "refs/heads/$b"; then
                        echo "Branch '$b' does not exist; aborting merge." >&2
                        return 1
                    fi
                done

                if [ -z "$message" ]; then
                    echo "Merging branches into $(command git rev-parse --abbrev-ref HEAD): ${branches[*]}"
                    read -r -p "Merge commit message: " message
                    [ -z "$message" ] && { echo "No merge message provided."; return 1; }
                fi

                if ! command git merge "${branches[@]}" -m "$message"; then
                    echo "Merge failed." >&2
                    return 1
                fi
                ;;
            *)
                if command git show-ref --verify --quiet "refs/heads/$sub"; then
                   command git checkout "$sub"
                else
                    shift
                    command git branch "$*"
                fi
                ;;
        esac
        ;;
    tag|tags)
        shift; sub="$1"
        case "$sub" in
            new)
                tagtype="$2"
                shift 2
                msg="$*"
                if [ -z "$tagtype" ]; then
                    echo "Error: Missing tag type (patch, minor, or major)."
                    return 1
                fi
                latest_tag=$(command git describe --tags --abbrev=0 2>/dev/null)
                if [ -z "$latest_tag" ]; then
                    new_tag="v0.1.0"
                else
                    IFS='.' read major minor patch <<< "${latest_tag#v}"
                    case "$tagtype" in
                        patch) patch=$((patch + 1));;
                        minor) minor=$((minor + 1)); patch=0;;
                        major) major=$((major + 1)); minor=0; patch=0;;
                        *)
                            echo "Invalid tag type: $tagtype. Use patch, minor, or major." && return 1;;
                    esac
                    new_tag="v$major.$minor.$patch"
                fi
                if [ -n "$msg" ]; then
                    command git tag "$new_tag" -m "$msg"
                else
                    command git tag "$new_tag"
                fi
                echo "Created new tag: $new_tag"
                ;;
            list|ls)
                command git tag --sort=-creatordate -n
                ;;
            rm)
                if [ -z "$2" ]; then
                    selected=$(command git tag --sort=-creatordate -l | \
                        fzf --multi --prompt="Tag to delete: " --height=30%)
                    [ -n "$selected" ] && \
                        for tag in $selected; do command git tag -d "$tag"; done
                else
                    command git tag -d "$2"
                fi
                ;;
            send)
                latest_tag=$(command git describe --tags --abbrev=0 2>/dev/null)
                [ -z "$latest_tag" ] && { echo "Error: No tags found to push."; return 1; }
                command git push origin "$latest_tag"
                ;;
            update)
                shift
                tag=""
                if [ $# -gt 0 ] && [[ "$1" != --* ]]; then
                    tag="$1"
                    shift
                fi

                if [ -z "$tag" ]; then
                    selected=$(command git tag --sort=-creatordate -n | \
                        fzf --prompt="Tag to update: " --height=30% | awk '{print $1}' | head -n1)
                    [ -z "$selected" ] && { echo "No tag selected."; return 1; }
                    tag="$selected"
                fi

                new_name=""
                new_desc=""

                while [ $# -gt 0 ]; do
                    case "$1" in
                        --name)
                            shift
                            new_name="$1"
                            ;;
                        --desc|--message|-m)
                            shift
                            new_desc="$1"
                            ;;
                        *)
                            echo "Unknown option for 'g tag update': $1" >&2
                            return 1
                            ;;
                    esac
                    shift
                done

                commit_ref=$(command git rev-list -n 1 "$tag" 2>/dev/null) || {
                    echo "Tag '$tag' not found." >&2
                    return 1
                }

                existing_desc=$(command git for-each-ref "refs/tags/$tag" --format='%(contents)' 2>/dev/null)

                if [ -z "$new_name" ]; then
                    read -rp "New tag name [$tag]: " new_name
                    [ -z "$new_name" ] && new_name="$tag"
                fi

                if [ -z "$new_desc" ]; then
                    if [ -n "$existing_desc" ]; then
                        echo "Current description:"
                        echo "---------------------"
                        echo "$existing_desc"
                        echo "---------------------"
                    fi
                    read -rp "New tag description (leave empty to keep current/none): " new_desc
                    if [ -z "$new_desc" ] && [ -n "$existing_desc" ]; then
                        new_desc="$existing_desc"
                    fi
                fi

                command git tag -d "$tag" >/dev/null 2>&1 || true

                if [ -n "$new_desc" ]; then
                    if ! command git tag -a "$new_name" -m "$new_desc" "$commit_ref"; then
                        echo "Failed to create updated annotated tag." >&2
                        return 1
                    fi
                else
                    if ! command git tag "$new_name" "$commit_ref"; then
                        echo "Failed to create updated tag." >&2
                        return 1
                    fi
                fi

                echo "Tag updated: $tag -> $new_name"
                ;;
            *)
                command git tag "$*"
                ;;
        esac
        ;;
    stage|staged)
        shift; sub="$1"
        case "$sub" in
            add)
                selected=$(git status --porcelain | \
                    awk '{if ($1 ~ /^[MARCU?]/) print $2}' | \
                    fzf --multi --prompt="Add file to stage: " --height=30%)
                [ -n "$selected" ] && command git add $selected
                ;;
            list|ls)
                command git diff --cached --name-only
                ;;
            rm)
                shift
                if [ "$#" -eq 0 ]; then
                    repo_root=$(git rev-parse --show-toplevel)
                    current_dir=$(pwd)
                    staged=$(git diff --cached --name-only | \
                        fzf --multi --prompt="Unstage file: " --height=30%)
                    if [ -n "$staged" ]; then
                        readarray -t files_to_unstage <<< "$staged"
                        files_for_reset=()
                        for file in "${files_to_unstage[@]}"; do
                            abs_from_root="$repo_root/$file"
                            rel_from_cwd=$(realpath --relative-to="$current_dir" "$abs_from_root" 2>/dev/null)
                            if [ -n "$rel_from_cwd" ] && [ -e "$rel_from_cwd" ]; then
                                files_for_reset+=("$rel_from_cwd")
                            else
                                files_for_reset+=("$file")
                            fi
                        done
                        if [ "${#files_for_reset[@]}" -eq 0 ]; then
                            echo "No selected files exist to unstage."
                            return 1
                        fi
                        if git reset HEAD -- "${files_for_reset[@]}" > /dev/null; then
                            echo "Unstaged files:"
                            for f in "${files_to_unstage[@]}"; do
                                echo "- $f"
                            done
                        else
                            echo "Error unstaging files." >&2
                        fi
                    fi
                else
                    if git reset HEAD -- "$@" > /dev/null; then
                        echo "Unstaged files:"
                        for f in "$@"; do
                            echo "- $f"
                        done
                    else
                        echo "Error unstaging files." >&2
                    fi
                fi
                ;;
            *)
                echo "Usage: g stage add/list/rm"
                ;;
        esac
        ;; 
    new)
        msg=""
        if [ -z "$2" ]; then
            read -e -p "Commit message: " msg
        else
            shift
            msg="$*"
        fi
        [ -z "$msg" ] && { echo "No message provided."; return 1; }
        command git commit -m "$msg"
        ;;
    list|ls)
        command git log --oneline --decorate --graph -n ${2:-10}
        ;;
    rm)
        shift
        local targets=()

        if [ "$#" -eq 0 ]; then
            local selected
            selected=$(command git log --oneline | \
                fzf --multi --prompt="Select commits to delete (oldest to newest): " --height=50%)
            [ -z "$selected" ] && { echo "No commit selected."; return 1; }

            while IFS= read -r line; do
                [ -z "$line" ] && continue
                local short="${line%% *}"
                if hash=$(command git rev-parse --verify "$short" 2>/dev/null); then
                    targets+=("$hash")
                fi
            done <<< "$selected"
        else
            local arg
            for arg in "$@"; do
                local ref hash
                if [[ "$arg" =~ ^[0-9]+$ ]]; then
                    local n="$arg"
                    if [ "$n" -lt 1 ]; then
                        echo "Numeric position '$n' must be >= 1." >&2
                        return 1
                    fi
                    if [ "$n" -eq 1 ]; then
                        ref="HEAD"
                    else
                        ref="HEAD~$n"
                    fi
                else
                    ref="$arg"
                fi

                if ! hash=$(command git rev-parse --verify "$ref" 2>/dev/null); then
                    echo "Commit '$arg' (resolved as '$ref') not found." >&2
                    return 1
                fi
                targets+=("$hash")
            done
        fi

        if [ "${#targets[@]}" -eq 0 ]; then
            echo "No commits selected." >&2
            return 1
        fi

        local uniq_targets=()
        local h s seen
        for h in "${targets[@]}"; do
            seen=0
            for s in "${uniq_targets[@]}"; do
                if [ "$s" = "$h" ]; then
                    seen=1
                    break
                fi
            done
            [ "$seen" -eq 0 ] && uniq_targets+=("$h")
        done

        local head_hash
        head_hash=$(command git rev-parse HEAD)
        for h in "${uniq_targets[@]}"; do
            if ! command git merge-base --is-ancestor "$h" "$head_hash" 2>/dev/null; then
                echo "Commit $h is not an ancestor of HEAD; cannot remove it with 'g rm'." >&2
                return 1
            fi
        done

        local base_commit=""
        while IFS= read -r c; do
            for h in "${uniq_targets[@]}"; do
                if [ "$h" = "$c" ]; then
                    base_commit="$h"
                    break 2
                fi
            done
        done < <(command git rev-list --reverse "$head_hash" 2>/dev/null)

        if [ -z "$base_commit" ]; then
            echo "Could not determine base commit for rebase." >&2
            return 1
        fi

        local parent_hash
        if ! parent_hash=$(command git rev-parse "${base_commit}^" 2>/dev/null); then
            echo "Cannot remove the root commit with this helper." >&2
            return 1
        fi

        echo "About to remove the following commits (this rewrites history):"
        for h in "${uniq_targets[@]}"; do
            command git log --oneline -1 "$h"
        done
        read -r -p "Proceed with removing these commits? [y/n] " answer
        case "$answer" in
            [Yy]*)
                ;;
            *)
                echo "Aborted."
                return 1
                ;;
        esac

        local git_dir
        git_dir=$(command git rev-parse --git-dir 2>/dev/null) || {
            echo "Not inside a git repository." >&2
            return 1
        }

        local seq_editor="$git_dir/g-rm-sequence-editor.sh"

        cat > "$seq_editor" <<'EOF'
#!/bin/sh
file="$1"
tmp="$file.tmp"
targets=" $G_RM_COMMITS_FULL "
: > "$tmp"

while IFS= read -r line; do
    case "$line" in
        pick\ *|edit\ *|reword\ *|fixup\ *|squash\ *)
            set -- $line
            cmd="$1"
            hash="$2"
            full_hash=$(command git rev-parse --verify "$hash" 2>/dev/null || echo "")
            if [ -n "$full_hash" ]; then
                case "$targets" in
                    *" $full_hash "*)
                        # Drop this commit
                        echo "drop ${line#* }" >> "$tmp"
                        continue
                        ;;
                esac
            fi
            echo "$line" >> "$tmp"
            ;;
        *)
            echo "$line" >> "$tmp"
            ;;
    esac
done < "$file"

mv "$tmp" "$file"
EOF
        chmod +x "$seq_editor"

        export G_RM_COMMITS_FULL="${uniq_targets[*]}"

        GIT_SEQUENCE_EDITOR="$seq_editor" command git rebase -i "$parent_hash"
        ;; 
    edit)
        target="$2"

        if [ -z "$target" ]; then
            selected=$(command git log --pretty=format:'%h %s [%an]' | \
                fzf --prompt="Select commit to edit: " --height=50%)
            [ -z "$selected" ] && { echo "No commit selected."; return 1; }
            commit_to_edit=$(awk '{print $1}' <<< "$selected")
        else
            if [[ "$target" =~ ^[0-9]+$ ]]; then
                commit_to_edit="HEAD~$target"
            else
                commit_to_edit="$target"
            fi
        fi

        if ! commit_hash=$(command git rev-parse --verify "$commit_to_edit" 2>/dev/null); then
            echo "Commit '$commit_to_edit' not found." >&2
            return 1
        fi

        if ! parent_hash=$(command git rev-parse "${commit_hash}^" 2>/dev/null); then
            echo "Editing the root commit in this non-interactive mode is not supported." >&2
            echo "You would need an interactive rebase for that specific case." >&2
            return 1
        fi

        current_branch=$(command git symbolic-ref --quiet --short HEAD 2>/dev/null)
        if [ -z "$current_branch" ]; then
            echo "You are not on a branch (detached HEAD). Aborting." >&2
            return 1
        fi

        git_dir=$(command git rev-parse --git-dir 2>/dev/null) || {
            echo "Not inside a git repository." >&2
            return 1
        }

        state_file="$git_dir/g-edit-state"
        if [ -f "$state_file" ]; then
            echo "There is already an edit in progress (state file: $state_file)." >&2
            echo "Finish it with 'g apply' or delete the state file manually before starting a new edit." >&2
            return 1
        fi

        {
            printf '%s\n' "$current_branch"
            printf '%s\n' "$commit_hash"
        } > "$state_file"

        short_hash=${commit_hash:0:7}
        work_branch="g-edit-${short_hash}"

        echo "Creating temporary work branch '$work_branch' from '$current_branch'..."
        command git branch "$work_branch" "$current_branch" || return 1
        command git checkout "$work_branch" || return 1

        command git reset --hard "$commit_hash" || return 1
        command git reset --soft "$parent_hash" || return 1

        cat <<EOF
Commit ${short_hash} has been opened for editing on temporary branch '$work_branch'.

1. Modify files as needed.
2. Commit your changes (one or more commits) on '$work_branch'.

When you are satisfied, run 'g apply' or 'g apply -d/--delete' to delete the temporary branch.
EOF
        ;;
    apply)
        shift
        delete_temp_branch=0
        while [ $# -gt 0 ]; do
            case "$1" in
                -d|--delete)
                    delete_temp_branch=1
                    ;;
                *)
                    echo "Unknown option for 'g apply': $1" >&2
                    echo "Usage: g apply [-d|--delete]" >&2
                    return 1
                    ;;
            esac
            shift
        done

        git_dir=$(command git rev-parse --git-dir 2>/dev/null) || {
            echo "Not inside a git repository." >&2
            return 1
        }

        state_file="$git_dir/g-edit-state"
        if [ ! -f "$state_file" ]; then
            echo "No pending edit state found. Run 'g edit <hash|number>' first." >&2
            return 1
        fi

        {
            read -r original_branch
            read -r old_commit_hash
        } < "$state_file"

        if [ -z "$original_branch" ] || [ -z "$old_commit_hash" ]; then
            echo "Edit state file '$state_file' is invalid. Delete it and run 'g edit' again." >&2
            return 1
        fi

        if ! command git rev-parse --verify "$original_branch" >/dev/null 2>&1; then
            echo "Original branch '$original_branch' not found. Aborting." >&2
            return 1
        fi

        if ! command git rev-parse --verify "$old_commit_hash" >/dev/null 2>&1; then
            echo "Old commit '$old_commit_hash' (recorded by g edit) not found. Aborting." >&2
            return 1
        fi

        echo "Applying edited history onto original branch '$original_branch'..."
        echo "Running: git rebase --onto HEAD ${old_commit_hash} ${original_branch}"
        command git rebase --onto HEAD "$old_commit_hash" "$original_branch" || return 1

        rm -f "$state_file"

        if [ "$delete_temp_branch" -eq 1 ]; then
            short_hash=${old_commit_hash:0:7}
            temp_branch="g-edit-${short_hash}"
            if command git show-ref --verify --quiet "refs/heads/$temp_branch"; then
                echo "Deleting temporary branch '$temp_branch'..."
                command git branch -D "$temp_branch"
            else
                echo "No temporary branch '$temp_branch' found to delete."
            fi
        fi

        echo
        echo "Rebase completed successfully."
        echo "You are now on branch '$original_branch' with the edited history applied."
        if [ "$delete_temp_branch" -eq 0 ]; then
            echo "If you created a temporary 'g-edit-<hash>' branch, you may delete it manually:"
            echo "  git branch -D g-edit-<hash>"
        fi
        ;;
    join)
        shift

        if ! command git diff-index --quiet HEAD --; then
            echo "Working tree is not clean. Commit or stash your changes before using 'g join'." >&2
            return 1
        fi

        git_dir=$(command git rev-parse --git-dir 2>/dev/null) || {
            echo "Not inside a git repository." >&2
            return 1
        }

        head_full=$(command git rev-parse HEAD)

        root_hash=$(command git rev-list --max-parents=0 HEAD 2>/dev/null | head -n1 || true)
        root_short=""
        if [ -n "$root_hash" ]; then
            root_short=$(command git rev-parse --short "$root_hash" 2>/dev/null || true)
        fi

        commits=()
        message=""

        if [ $# -eq 0 ]; then
            selected=$(command git log --pretty=format:'%h %s [%an]' | \
                awk -v r="$root_short" 'r=="" || $1 != r' | \
                fzf --multi --prompt="Select commits to squash: " --height=50%)
            [ -z "$selected" ] && { echo "No commits selected."; return 1; }

            readarray -t short_hashes <<< "$(printf '%s\n' "$selected" | awk '{print $1}')"

            for h in "${short_hashes[@]}"; do
                full=$(command git rev-parse "$h" 2>/dev/null) || {
                    echo "Invalid commit reference: $h" >&2
                    return 1
                }
                if [ -n "$root_hash" ] && [ "$full" = "$root_hash" ]; then
                    echo "Skipping root commit $h; it cannot be squashed." >&2
                    continue
                fi
                commits+=( "$full" )
            done

            read -r -p "Squash commit message: " message
            [ -z "$message" ] && { echo "No message provided."; return 1; }
        else
            while [ $# -gt 0 ]; do
                case "$1" in
                    -m|--message)
                        shift
                        message="$*"
                        break
                        ;;
                    *)
                        full=$(command git rev-parse "$1" 2>/dev/null) || {
                            echo "Invalid commit reference: $1" >&2
                            return 1
                        }
                        if [ -n "$root_hash" ] && [ "$full" = "$root_hash" ]; then
                            echo "Root commit ($1) cannot be squashed; aborting." >&2
                            return 1
                        fi
                        commits+=( "$full" )
                        shift
                        ;;
                esac
            done

            if [ "${#commits[@]}" -lt 1 ]; then
                echo "No commits specified for 'g join'." >&2
                return 1
            fi

            if [ -z "$message" ]; then
                read -r -p "Squash commit message: " message
                [ -z "$message" ] && { echo "No message provided."; return 1; }
            fi
        fi

        if [ "${#commits[@]}" -lt 2 ]; then
            echo "Select/specify at least two non-root commits to squash." >&2
            return 1
        fi

        for c in "${commits[@]}"; do
            if ! command git merge-base --is-ancestor "$c" "$head_full" 2>/dev/null; then
                echo "Commit $c is not an ancestor of HEAD. Aborting." >&2
                return 1
            fi
        done

        oldest=""
        max_dist=-1
        for c in "${commits[@]}"; do
            if command git rev-parse "${c}^" >/dev/null 2>&1; then
                dist=$(command git rev-list --count "${c}^..HEAD")
            else
                dist=$(command git rev-list --count "${c}..HEAD")
            fi
            if [ "$dist" -gt "$max_dist" ]; then
                max_dist=$dist
                oldest="$c"
            fi
        done

        if ! parent_oldest=$(command git rev-parse "${oldest}^" 2>/dev/null); then
            echo "Cannot squash including the root commit with this helper. Use an interactive rebase instead." >&2
            return 1
        fi

        oldest_short=${oldest:0:7}
        echo "About to squash all commits from ${oldest_short} up to HEAD into a single commit."
        echo "New commit message:"
        echo "  $message"
        read -r -p "Proceed? This rewrites history. [y/N] " answer
        case "$answer" in
            [Yy]*)
                ;;
            *)
                echo "Aborted."
                return 1
                ;;
        esac

        command git reset --soft "$parent_oldest" || return 1
        command git commit -m "$message" || return 1

        echo "Squashed commits from ${oldest_short}..HEAD into a single commit."
        ;;
    update)
        shift

        local target_ref=""
        local commit_hash=""
        local new_message=""

        if [ "$#" -eq 0 ]; then
            local selected
            selected=$(command git log --pretty=format:'%h %s [%an]' | \
                fzf --prompt="Select commit to update: " --height=50% --layout=reverse --border)
            [ -z "$selected" ] && { echo "No commit selected."; return 1; }
            target_ref=$(awk '{print $1}' <<< "$selected")
        else
            target_ref="$1"
            shift

            if [[ "$target_ref" =~ ^[0-9]+$ ]]; then
                target_ref="HEAD~$target_ref"
            fi

            while [ "$#" -gt 0 ]; do
                case "$1" in
                    -m|--message)
                        shift
                        new_message="$*"
                        break
                        ;;
                    *)
                        echo "Unknown option for 'g rename': $1" >&2
                        return 1
                        ;;
                esac
            done
        fi

        if ! commit_hash=$(command git rev-parse --verify "$target_ref" 2>/dev/null); then
            echo "Commit '$target_ref' not found." >&2
            return 1
        fi

        if [ -z "$new_message" ]; then
            local old_message
            old_message=$(command git log -1 --pretty=%B "$commit_hash")
            echo "Current commit message:"
            echo "-----------------------"
            echo "$old_message"
            echo "-----------------------"
            read -r -p "New commit message: " new_message
            [ -z "$new_message" ] && { echo "No new message provided."; return 1; }
        fi

        local head_hash
        head_hash=$(command git rev-parse HEAD)

        if [ "$commit_hash" = "$head_hash" ]; then
            command git commit --amend -m "$new_message"
            return $?
        fi

        local parent_hash
        if ! parent_hash=$(command git rev-parse "${commit_hash}^" 2>/dev/null); then
            echo "Cannot rename the root commit with this helper." >&2
            return 1
        fi

        local git_dir
        git_dir=$(command git rev-parse --git-dir 2>/dev/null) || {
            echo "Not inside a git repository." >&2
            return 1
        }

        local seq_editor="$git_dir/g-rename-sequence-editor.sh"
        local msg_editor="$git_dir/g-rename-msg-editor.sh"

        if [ ! -x "$seq_editor" ]; then
            cat > "$seq_editor" <<'EOF'
#!/bin/sh
file="$1"
tmp="$file.tmp"
: > "$tmp"
target="$G_RENAME_TARGET"
while IFS= read -r line; do
    case "$line" in
        "pick $target "*)
            echo "reword ${line#pick }" >> "$tmp"
            ;;
        *)
            echo "$line" >> "$tmp"
            ;;
    esac
done < "$file"
mv "$tmp" "$file"
EOF
            chmod +x "$seq_editor"
        fi

        if [ ! -x "$msg_editor" ]; then
            cat > "$msg_editor" <<'EOF'
#!/bin/sh
file="$1"
printf '%s\n' "$G_RENAME_NEW_MESSAGE" > "$file"
EOF
            chmod +x "$msg_editor"
        fi

        export G_RENAME_TARGET="$commit_hash"
        export G_RENAME_NEW_MESSAGE="$new_message"

        GIT_SEQUENCE_EDITOR="$seq_editor" GIT_EDITOR="$msg_editor" command git rebase -i "$parent_hash"
        ;;
    send)
        shift
        local force_flag=0
        local target_ref="HEAD"

        while [ $# -gt 0 ]; do
            case "$1" in
                -f|--force)
                    force_flag=1
                    ;;
                *)
                    target_ref="$1"
                    ;;
            esac
            shift
        done

        if [ "$force_flag" -eq 1 ]; then
            command git push --force origin "$target_ref"
        else
            command git push origin "$target_ref"
        fi
        ;; 
    diff)
        if [[ -z "$2" ]]; then
            git diff
            return
        fi
        shift 1
        git difftool -t vimdiff -y "$@"
        ;;
    .)
        shift
        if [ -z "$1" ]; then
           g info 
        elif [[ "$1" == "." ]]; then
            if command git add .; then
                echo "All modified files in \"$PWD\" added to stage."
            else
                echo "Error adding all changes in \"$PWD\" to the staging area." >&2
            fi
        elif [ "$1" = "all" ]; then
            repo_root=$(command git rev-parse --show-toplevel || pwd)
            pushd "$repo_root" > /dev/null || return 1
            if command git add .; then
                echo "All modified files added to stage."
            else
                echo "Error adding all changes to the staging area." >&2
            fi
            popd > /dev/null || return 1
        else
            if command git add -- "$@"; then
                staged_now=$(git diff --cached --name-only -- "$@" 2>/dev/null | sed '/^$/d')
                if [ -z "$staged_now" ]; then
                    echo "No changes added to stage for given paths."
                    return 0
                fi
                echo "Files added to stage:"
                for i in $staged_now; do
                    if [ -d "$i" ]; then
                        echo "- $i/*"
                    else
                        echo "- $i"
                    fi
                done
            else
                echo "Error adding specified files to the staging area." >&2
            fi
        fi
        ;; 
    ,)
        if [[ -z "$2" ]]; then
            g branch
            return
        fi
        branches=$(command git branch --format="%(refname:short)")
        for branch in $branches; do
            if [[ "$2" == "$branch" ]]; then
                g branch $branch
                return
            fi
        done
        g branch new "$2"
        ;;
    ..)
        shift
        if [ "$#" -eq 0 ]; then
            g stage rm
        else
            g stage rm "$@"
        fi
        ;;
    ,.|.,)
        g stage ls
        ;;
    git)
        shift
        command git "$@"
        ;;
    *)
        if [ -n "$1" ] && [[ "$1" == *: ]]; then
            local msg="$*"
            command git commit -m "$msg"
            return
        else
            echo "Option not defined for 'g'."
        fi
        ;;
    esac
}

_g_completion() {
    local cur prev_word
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev_word="${COMP_WORDS[COMP_CWORD-1]}"

    local top_level_commands="apply join diff undo info branch remote tag stage new list rm edit rename send conflict git . .. ,."

    local branch_subcommands="new list rm send rename rebase ff merge"

    local tag_subcommands="new list rm send edit"
    local tag_new_types="patch minor major"

    local stage_subcommands="add list rm"

    case "${COMP_CWORD}" in
        1)
            COMPREPLY=( $(compgen -W "${top_level_commands}" -- "${cur}") )
            ;;
        2)
            case "${prev_word}" in
                ff|push|pull)
                    if [[ "${prev_word}" == "ff" || "${prev_word}" == "push" || "${prev_word}" == "pull" ]]; then
                        local remote_branches
                        remote_branches=$(git branch -r 2>/dev/null | sed 's/origin\///g' | grep -v 'HEAD')
                        COMPREPLY=( $(compgen -W "${remote_branches}" -- "${cur}") )
                    fi
                    COMPREPLY+=( $(compgen -f -d -- "${cur}") )
                    ;;
                conflict)
                    local branches
                    branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                    COMPREPLY=( $(compgen -W "ls resolve diff HEAD ${branches}" -- "${cur}") )
                    ;;
                undo)
                    COMPREPLY=( $(compgen -W "1 2 3 4 5" -- "${cur}") )
                    ;;
                branch)
                    local existing_branches
                    existing_branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                    COMPREPLY=( $(compgen -W "${branch_subcommands} ${existing_branches}" -- "${cur}") )
                    ;;
                send)
                    local branches
                    branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                    COMPREPLY=( $(compgen -W "-f --force ${branches}" -- "${cur}") )
                    ;;
                remote)
                    COMPREPLY=( $(compgen -W "new list ls rm edit" -- "${cur}") )
                    ;;
                tag|tags)
                    COMPREPLY=( $(compgen -W "${tag_subcommands}" -- "${cur}") )
                    ;;
                apply)
                    COMPREPLY=( $(compgen -W "-d --delete" -- "${cur}") )
                    ;;
                stage|staged)
                    COMPREPLY=( $(compgen -W "${stage_subcommands}" -- "${cur}") )
                    ;;
                ls|list)
                    COMPREPLY=( $(compgen -W "10 20 30" -- "${cur}") )
                    ;;
                rm)
                    local hashes
                    hashes=$(git log --pretty=format:'%h' -n 50 2>/dev/null)
                    COMPREPLY=( $(compgen -W "${nums} ${hashes}" -- "${cur}") )
                    ;;
                rebase)
                    local remote_branches
                    remote_branches=$(git branch -r 2>/dev/null | sed 's/origin\///g' | grep -v 'HEAD')
                    COMPREPLY=( $(compgen -W "1 2 3 4 5 ${remote_branches}" -- "${cur}") )
                    ;;
                .)
                    local unstaged_files
                    unstaged_files=$(
                        {
                            git diff --name-only;
                            git ls-files --others --exclude-standard;
                        } 2>/dev/null | sort -u
                    )
                    COMPREPLY=( $(compgen -W "${unstaged_files}" -- "${cur}") )
                    ;;
                ..)
                    local staged_files
                    staged_files=$(git diff --cached --name-only 2>/dev/null)
                    COMPREPLY=( $(compgen -W "${staged_files}" -- "${cur}") )
                    ;;
                force)
                    local remote_branches2
                    remote_branches2=$(git branch -r 2>/dev/null | sed 's/origin\///g' | grep -v 'HEAD')
                    COMPREPLY=( $(compgen -W "${remote_branches2}" -- "${cur}") )
                    ;;
                edit)
                    local nums="0 1 2 3 4 5 10"
                    local hashes
                    hashes=$(git log --pretty=format:'%h' -n 50 2>/dev/null)
                    COMPREPLY=( $(compgen -W "${nums} ${hashes}" -- "${cur}") )
                    ;;
                join)
                    local root_hash root_short hashes
                    root_hash=$(git rev-list --max-parents=0 HEAD 2>/dev/null | head -n1 || true)
                    if [ -n "$root_hash" ]; then
                        root_short=$(git rev-parse --short "$root_hash" 2>/dev/null || true)
                    fi
                    hashes=$(git log --pretty=format:'%h' -n 50 2>/dev/null | \
                             awk -v r="$root_short" 'r=="" || $1 != r')
                    COMPREPLY=( $(compgen -W "--message ${hashes}" -- "${cur}") )
                    ;;
                rename)
                    local nums="0 1 2 3 4 5 10"
                    local hashes
                    hashes=$(git log --pretty=format:'%h' -n 50 2>/dev/null)
                    COMPREPLY=( $(compgen -W "${nums} ${hashes}" -- "${cur}") )
                    ;;
                *)
                    ;;
            esac
            ;;
        3)
            local grand_prev_word="${COMP_WORDS[COMP_CWORD-2]}"
            if [[ "${COMP_WORDS[1]}" == "join" ]]; then
                local root_hash root_short hashes
                root_hash=$(git rev-list --max-parents=0 HEAD 2>/dev/null | head -n1 || true)
                if [ -n "$root_hash" ]; then
                    root_short=$(git rev-parse --short "$root_hash" 2>/dev/null || true)
                fi
                hashes=$(git log --pretty=format:'%h' -n 50 2>/dev/null | \
                         awk -v r="$root_short" 'r=="" || $1 != r')
                COMPREPLY=( $(compgen -W "--message ${hashes}" -- "${cur}") )
                return
            fi
            case "${grand_prev_word}" in
                branch)
                    case "${prev_word}" in
                        new)
                            ;;
                        rm|send)
                            local local_branches
                            local_branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                            COMPREPLY=( $(compgen -W "${local_branches}" -- "${cur}") )
                            ;;
                        rename)
                            local local_branches
                            local_branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                            COMPREPLY=( $(compgen -W "${local_branches} --name" -- "${cur}") )
                            ;;
                        rebase|ff)
                            local local_branches
                            local_branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                            COMPREPLY=( $(compgen -W "./HEAD ${local_branches} -r --remote" -- "${cur}") )
                            ;;
                        merge)
                            local local_branches
                            local_branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                            COMPREPLY=( $(compgen -W "${local_branches} -m --message" -- "${cur}") )
                            ;;
                    esac
                    ;;
                conflict)
                    case "${prev_word}" in
                        ls|resolve|diff)
                            local files
                            files=$(git diff --name-only --diff-filter=U 2>/dev/null)
                            COMPREPLY=( $(compgen -W "${files}" -- "${cur}") )
                            ;;
                    esac
                    ;;
                remote)
                    case "${prev_word}" in
                        new)
                            COMPREPLY=( $(compgen -W "--name --url" -- "${cur}") )
                            ;;
                        rm|edit)
                            local remotes
                            remotes=$(git remote 2>/dev/null)
                            COMPREPLY=( $(compgen -W "${remotes}" -- "${cur}") )
                            ;;
                    esac
                    ;;
                tag|tags)
                    case "${prev_word}" in
                        new)
                            COMPREPLY=( $(compgen -W "${tag_new_types}" -- "${cur}") )
                            ;;
                        rm|send)
                            local existing_tags
                            existing_tags=$(git tag -l 2>/dev/null)
                            COMPREPLY=( $(compgen -W "${existing_tags}" -- "${cur}") )
                            ;;
                        edit)
                            local existing_tags2
                            existing_tags2=$(git tag -l 2>/dev/null)
                            COMPREPLY=( $(compgen -W "${existing_tags2}" -- "${cur}") )
                            ;;
                    esac
                    ;;
                stage|staged)
                    case "${prev_word}" in
                        add|rm)
                            if [[ "${prev_word}" == "add" ]]; then
                                local unstaged_files
                                unstaged_files=$(git status --porcelain 2>/dev/null | awk '{if ($1 !~ /^[MARCU?]/) print $2}')
                                COMPREPLY=( $(compgen -f -d -W "${unstaged_files}" -- "${cur}") )
                            fi
                            if [[ "${prev_word}" == "rm" ]]; then
                                local staged_files
                                staged_files=$(git diff --cached --name-only 2>/dev/null)
                                COMPREPLY=( $(compgen -f -d -W "${staged_files}" -- "${cur}") )
                            fi
                            ;;
                    esac
                    ;;
            esac
            ;;
        4)
            if [[ "${COMP_WORDS[1]}" == "tag" || "${COMP_WORDS[1]}" == "tags" ]] && \
               [[ "${COMP_WORDS[2]}" == "edit" ]]; then
                COMPREPLY=( $(compgen -W "--name --desc" -- "${cur}") )
            elif [[ "${COMP_WORDS[1]}" == "remote" && "${COMP_WORDS[2]}" == "edit" ]]; then
                COMPREPLY=( $(compgen -W "--name --url" -- "${cur}") )
            fi
            ;;
        *)
            case "${COMP_WORDS[1]}" in
                branch)
                    case "${COMP_WORDS[2]}" in
                        rebase|ff)
                            if [[ "${prev_word}" == "-r" || "${prev_word}" == "--remote" ]]; then
                                local remotes
                                remotes=$(git remote 2>/dev/null)
                                COMPREPLY=( $(compgen -W "${remotes}" -- "${cur}") )
                            else
                                local local_branches
                                local_branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                                COMPREPLY=( $(compgen -W "./HEAD ${local_branches} -r --remote" -- "${cur}") )
                            fi
                            ;;
                        merge)
                            if [[ "${prev_word}" == "-m" || "${prev_word}" == "--message" ]]; then
                                COMPREPLY=()
                            else
                                local local_branches
                                local_branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                                COMPREPLY=( $(compgen -W "${local_branches} -m --message" -- "${cur}") )
                            fi
                            ;;
                        rename)
                            if [[ "${prev_word}" == "--name" ]]; then
                                COMPREPLY=()
                            else
                                local local_branches
                                local_branches=$(git branch --format="%(refname:short)" 2>/dev/null)
                                COMPREPLY=( $(compgen -W "${local_branches} --name" -- "${cur}") )
                            fi
                            ;;
                    esac
                    ;;
                remote)
                    if [[ "${COMP_WORDS[2]}" == "rm" ]]; then
                        local remotes
                        remotes=$(git remote 2>/dev/null)
                        COMPREPLY=( $(compgen -W "${remotes}" -- "${cur}") )
                    fi
                    ;;
                join)
                    local root_hash root_short hashes
                    root_hash=$(git rev-list --max-parents=0 HEAD 2>/dev/null | head -n1 || true)
                    if [ -n "$root_hash" ]; then
                        root_short=$(git rev-parse --short "$root_hash" 2>/dev/null || true)
                    fi
                    hashes=$(git log --pretty=format:'%h' -n 50 2>/dev/null | \
                             awk -v r="$root_short" 'r=="" || $1 != r')
                    COMPREPLY=( $(compgen -W "--message ${hashes}" -- "${cur}") )
                    ;; 
                .)
                    local unstaged_files
                    unstaged_files=$(
                        {
                            git diff --name-only;
                            git ls-files --others --exclude-standard;
                        } 2>/dev/null | sort -u
                    )
                    COMPREPLY=( $(compgen -W "${unstaged_files}" -- "${cur}") )
                    ;;
                ..)
                    local staged_files
                    staged_files=$(git diff --cached --name-only 2>/dev/null)
                    COMPREPLY=( $(compgen -W "${staged_files}" -- "${cur}") )
                    ;;
                *)
                    ;;
            esac
            ;;
    esac
}

complete -F _g_completion g

